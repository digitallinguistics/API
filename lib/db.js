'use strict';
const credentials = require('./credentials');
const DocumentDB = require('documentdb');

const documentdb = new DocumentDB.DocumentClient(credentials.documentdb.host, { masterKey: credentials.documentdb.key });

/**
 * A helper that creates the database request and retries the request if throttled
 * @param  {function} request             The DocumentDB operation to execute.
 * @param  {any} args                     An argument or array of arguments to pass to the request function, <em>without</em> the response handler
 * @param  {function} handler             The handler for the request. Takes two parameters: error and response.
 */
const makeRequest = (operation, args, handler) => {
  args = Array.isArray(args) ? args : [args];
  const processResponse = (err, res, headers, task) => {
    if (err && err.code == 429) { setTimeout(task, (+headers['x-ms-retry-after-ms']) + 1); }
    else { handler(err, res); }
  };
  if (operation === 'readCollections') {
    let task = () => documentdb[operation](...args).toArray((err, res, headers) => processResponse(err, res, headers, task));
    task();
  } else {
    let task = () => documentdb[operation](...args, (err, res, headers) => processResponse(err, res, headers, task));
    task();
  }
};

/** The db object initializes the DocumentDB database and saves information about the database and its collections */
const db = (() => {

  /**
   * The unique resource ID (RID) for the database
   * @type {string}
   */
  this.rid = global.env === 'production' ? credentials.documentdb.rid : credentials.documentdb.devRid;

  /**
   * The self link for the database
   * @type {string}
   */
  this.link = (() => 'dbs/' + this.rid + '/')();

  /**
   * A hash containing any global stored procedures to be upserted to each collection upon initialization.
   * @type {object}
   * @prop {object} getItemsByIds           Retrieves items from a collection by ID.
   */
  this.sprocs = {
    getItemsByIds: require('./sprocs/getItemsByIds')
  };

  /**
   * A hash containing any collection-specific stored procedures to be upserted on initialization.
   * @type {object}
   */
  this.collectionSprocs = {
    users: {
      updateUserActivity: require('./sprocs/updateUserActivity')
    }
  };

  /**
   * A hash of collections in the database (autogenerated on initialization)
   * @type {array}
   */
  this.collections = {};

  /** Initializes the database */
  this.initCollections = () => new Promise((resolve, reject) => {

    makeRequest('readCollections', this.link, (err, colls) => {
      if (err) { reject(convertResponse(err)); }

      var collsUploaded = 0;

      colls.forEach(coll => {

        const readCounter = () => new Promise((resolve, reject) => {
          const handler = (err, res) => {
            if (err) { reject(convertResponse(err)); }
            resolve(res);
          };
          makeRequest('executeStoredProcedure', [this.collections[coll.id].sprocs.getItemsByIds.link, [['counter'], 'id']], handler);
        });

        const uploadCounter = res => new Promise((resolve, reject) => {
          if (res.length === 0) {
            const counterDoc = { id: 'counter', counter: 0, services: {}, permissions: {} };
            const handler = (err, res) => {
              if (err) { reject(convertResponse(err)); }
              this.collections[coll.id].counterLink = res._self;
              resolve();
            };
            makeRequest('createDocument', [this.collections[coll.id].link, counterDoc], handler);
          } else {
            this.collections[coll.id].counterLink = res[0]._self;
            resolve();
          }
        });

        const upsertCollectionSprocs = () => new Promise((resolve, reject) => {
          if (coll.id in this.collectionSprocs) {
            var sprocsUploaded = 0;
            Object.keys(this.collectionSprocs[coll.id]).forEach(sprocName => {
              const handler = (err, res) => {
                if (err) { reject(convertResponse(err)); }
                this.collections[coll.id].sprocs[sprocName] = { link: res._self, rid: res._rid };
                sprocsUploaded++;
                if (Object.keys(this.collectionSprocs).length === sprocsUploaded) { resolve(); }
              };
              makeRequest('upsertStoredProcedure', [this.collections[coll.id].link, this.collectionSprocs[coll.id][sprocName]], handler);
            });
          } else {
            resolve();
          }
        });

        const upsertGlobalSprocs = () => new Promise((resolve, reject) => {
          var sprocsUploaded = 0;
          Object.keys(this.sprocs).forEach(sprocName => {
            const handler = (err, res) => {
              if (err) { reject(convertResponse(err)); }
              this.collections[coll.id].sprocs[sprocName] = { link: res._self, rid: res._rid };
              sprocsUploaded++;
              if (Object.keys(this.sprocs).length === sprocsUploaded) { resolve(); }
            };
            makeRequest('upsertStoredProcedure', [this.collections[coll.id].link, this.sprocs[sprocName]], handler);
          });
        });

        this.collections[coll.id] = {
          link: coll._self,
          rid: coll._rid,
          sprocs: {}
        };

        upsertGlobalSprocs(coll)
        .then(upsertCollectionSprocs)
        .then(readCounter)
        .then(uploadCounter)
        .then(() => {
          collsUploaded++;
          if (collsUploaded === colls.length) { resolve(); }
        }).catch(reject);

      });
    });

  });

  /**
   * Calls the initialization function and returns a Promise that resolves when the database is ready. This method should be called before any further calls to the database are made.
   * @return {[type]} [description]
   */
  this.ready = () => new Promise((resolve, reject) => this.initCollections().then(resolve).catch(reject));

  return this;

})();

/**
 * A convenience function that autoincrements the ID for a collection and returns the new ID
 * @param {string} collection     The collection to get the autoincremented ID of.
 * @returns                       Returns the new autoincremented ID.
 */
const createId = coll => new Promise((resolve, reject) => {

  if (typeof coll !== 'string') { reject(jsonResponse('Collection parameter must be a string.', 400)); }

  const getCounter = () => new Promise((resolve, reject) => {
    const handler = (err, res) => {
      if (err) { reject(convertResponse(err)); }
      resolve(res);
    };
    makeRequest('readDocument', db.collections[coll].counterLink, handler);
  });

  const increment = counterDoc => new Promise((resolve, reject) => {
    counterDoc.counter++;
    const handler = (err, res) => {
      if (err) { reject(convertResponse(err)); }
      resolve(String(res.counter));
    };
    makeRequest('upsertDocument', [db.collections[coll].link, counterDoc], handler);
  });

  getCounter().then(increment).then(resolve).catch(reject);

});

/**
 * Creates a database object
 * @param   {string} collection              The collection to add the object to.
 * @param   {(object|array)} items           A single object or array of objects to add to the collection.
 * @param   {object} [opts]                  An optional options hash.
 * @prop    {string} [opts.createId]         If true, autoincrements the ID for the new object. If false, DocumentDB automatically assigns a random GUID.
 * @returns {(object|array)}                 Returns the new database object(s) as either an object or an array.
 */
exports.create = (coll, input, opts) => new Promise((resolve, reject) => {
  if (typeof coll !== 'string') { reject(jsonResponse('Collection parameter must be a string.', 400)); }

  opts = opts || {};
  const isArr = input instanceof Array;
  const items = isArr ? input : [input];
  const results = [];

  const makeRequests = () => items.reduce((promise, item) => {

    return promise.then(() => new Promise((resolve, reject) => {

      if (coll == 'users') { item.services = item.services || {}; }

      const handler = (err, res) => {
        if (err) { reject(convertResponse(err)); }
        results.push(res);
        resolve();
      };

      const create = () => makeRequest('createDocument', [db.collections[coll].link, item], handler);

      if (opts.createId) {
        createId(coll).then(id => {
          item.id = id;
          create();
        }).catch(reject);
      } else {
        create();
      }

    })).catch(reject);

  }, Promise.resolve());

  makeRequests().then(() => resolve(isArr ? results : results[0])).catch(reject);

});

/**
 * Deletes one or more resources from the database.
 * @param   {string} collection      The collection to delete the resource(s) from.
 * @param   {(string|array)} rids    An RID or array of RIDs for the resources to delete.
 * @returns {(object|array)}         If the delete operation is successful, returns an object with a <code>status</code> property equal to <code>204</code> for each item deleted. If the delete operation fails for any operation (say, because of an incorrect ID), a single error object with a <code>status: 4xx || 5xx</code> attribute is returned.
 */
exports.delete = (coll, input) => new Promise((resolve, reject) => {

  if (typeof coll !== 'string') { reject(jsonResponse('Collection parameter must be a string.', 400)); }

  const isArr = input instanceof Array;
  const rids = isArr ? input : [input];
  const results = [];

  const makeRequests = () => rids.reduce((promise, rid) => {
    return promise.then(() => new Promise((resolve, reject) => {
      const link = `${db.collections[coll].link}docs/${rid}/`;
      const handler = (err, res) => {
        if (err && err.code == 404) { reject(jsonResponse(`Item with RID ${rid} not found.`, 404)); }
        else if (err) { reject(convertResponse(err)); }
        else {
          results.push(jsonResponse(`RID ${rid} successfully deleted.`, 204));
          resolve(res);
        }
      };
      makeRequest('deleteDocument', link, handler);
    }));
  }, Promise.resolve());

  makeRequests().then(() => resolve(isArr ? results : results[0])).catch(reject);

});

/**
 * Retrieves one or more resources from the database by their RIDs.
 * @param   {string} collection      The collection to retrieve the items from.
 * @param   {(object|array)} rids    An RID or an array of RIDs for the resources to retrieve.
 * @returns {(object|array)}         Returns the requested object or an array of the requested objects.
 */
exports.get = (coll, input) => new Promise ((resolve, reject) => {

  if (typeof coll !== 'string') { reject(jsonResponse('Collection parameter must be a string.', 400)); }

  const isArr = input instanceof Array;
  const rids = isArr ? input : [input];
  const results = [];

  const makeRequests = () => rids.reduce((promise, rid) => {
    return promise.then(() => new Promise((resolve, reject) => {
      const link = `${db.collections[coll].link}docs/${rid}/`;
      const handler = (err, res) => {
        if (err && err.code == 404) { reject(jsonResponse(`Item with RID ${rid} not found.`, 404)); }
        else if (err) { reject(convertResponse(err)); }
        else { results.push(res); resolve(); }
      };
      makeRequest('readDocument', link, handler);
    }));
  }, Promise.resolve());

  makeRequests().then(() => resolve(isArr ? results : results[0])).catch(reject);

});

/**
 * Retrieves items from the database by ID, service ID, or email ID
 * @param   {string} collection                      The collection to retrieve the resources from.
 * @param   {(string|array)} ids                     An ID or array of IDs for the resources to retrieve.
 * @param   {object} [opts]                          An optional options hash.
 * @prop    {string} [opts.idType|opts.id_type]      <code>id</code> (including email), or <code>serviceId</code> (also accepts <code>service_id</code>)
 * @prop    {string} [opts.service]                  The 3rd-party service to match for service ID. Currently required if <code>idType</code> is set to <code>serviceId</code>.
 * @return  {(object|array)}                         The object or array of objects retrieved from the database.
 */
exports.getById = (coll, input, opts) => new Promise((resolve, reject) => {
  if (typeof coll !== 'string') { reject(jsonResponse('Collection parameter must be a string.', 400)); }

  opts = opts || {};
  opts.idType = opts.idType || opts.id_type;
  const isArr = Array.isArray(input);
  const ids = isArr ? input : [input];

  opts.idType = (opts.idType === 'serviceId' || opts.idType === 'service_id') ? 'serviceId' : 'id';

  const handler = (err, res) => {
    if (err) { reject(convertResponse(err)); }
    else if (res.length === 0) { reject(jsonResponse('No resource(s) found with the specified ID(s).', 404)); }
    else { resolve(isArr ? res : res[0]); }
  };

  makeRequest('executeStoredProcedure', [db.collections[coll].sprocs.getItemsByIds.link, [ids, opts.idType, { service: opts.service }]], handler);

});

/**
 * 'Logs in' the user by updating the <code>lastActive</code> attribute. Should be called each time the user successfully completes a database operation (unless the <code>lastActive</code> attribute was updated elsewhere during the operation).
 * @param {string}        The RID of the user to log in.
 */
exports.login = rid => new Promise((resolve, reject) => {
  const handler = (err, res) => {
    if (err) { reject(convertResponse(err)); }
    else if (res.status == 201) { resolve(jsonResponse('User activity updated.', 200)); }
  };
  makeRequest('executeStoredProcedure', [db.collections.users.sprocs.updateUserActivity.link, [rid]], handler);
});

/**
 * 'Logs out' the user by setting the <code>lastActive</code> attribute to 0.
 * @param {string}          The RID of the user to log out.
 */
exports.logout = rid => new Promise((resolve, reject) => {
  const handler = (err, res) => {
    if (err) { reject(convertResponse(err)); }
    else if (res.status == 201) { resolve(jsonResponse('User is now logged out.', 200)); }
  };
  makeRequest('executeStoredProcedure', [db.collections.users.sprocs.updateUserActivity.link, [rid, true]], handler);
});

/** Exports the database initialization function. */
exports.ready = db.ready;

/**
 * Upserts one or more resources to the database.
 * @param   {string} collection            The collection to upsert items to.
 * @param   {(object|array)} items         The item or items to upsert to the database.
 * @param   {object} [opts]                An optional options hash.
 * @prop    {string} [opts.createId]       If true, autoincrements the ID for the upserted items. ()<strong>Warning:</strong> this will overwrite any existing ID on the object, thus creating a duplicate object.) If false, DocumentDB automatically assigns the resource a GUID if it does not have an ID already.
 * @returns {(object|array)}               Returns the upserted object or array of objects.
 */
exports.upsert = (coll, input, opts) => new Promise((resolve, reject) => {

  if (typeof coll !== 'string') { reject(jsonResponse('Collection parameter must be a string.', 400)); }

  opts = opts || {};
  const isArr = input instanceof Array;
  const items = (isArr ? input : [input]).map(item => JSON.parse(JSON.stringify(item)));
  const results = [];

  const makeRequests = () => items.reduce((promise, item) => {
    return promise.then(() => new Promise((resolve, reject) => {
      const upsert = id => new Promise((resolve, reject) => {
        if (id) {
          item.id = id;
          Object.keys(item).forEach(key => {
            if (key.startsWith('_')) { delete item[key]; }
          });
        }
        item.permissions = item.permissions || { owner: [], viewer: [], contributor: [], public: false };
        if (coll === 'user') { item.services = item.services || {}; }
        const handler = (err, res) => {
          if (err) { reject(convertResponse(err)); }
          results.push(res); resolve();
        };
        makeRequest('upsertDocument', [db.collections[coll].link, item], handler);
      });
      if (opts.createId) { createId(coll).then(upsert).then(() => resolve(isArr ? results : results[0])).catch(reject); }
      else { upsert().then(() => resolve(isArr ? results : results[0])).catch(reject); }
    }));
  }, Promise.resolve());

  makeRequests().then(resolve).catch(reject);

});
